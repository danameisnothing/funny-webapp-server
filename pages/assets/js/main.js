const LASTUPDATE_LEVEL = {
  GOOD: {
    color: "169c62",
    msg: "",
  },
  SLIGHT_OUTOFDATE: {
    color: "cf550d",
    msg: "Will likely lag behind the actual livestream within tolerable latencies (4 - 15 seconds)",
  },
  OUTOFDATE: {
    color: "e73417",
    msg: "Data from this website shouldn't be relied upon. Please wait until the website owner updates the relevant information",
  },
  OUTOFDATE_SEVERE: {
    color: "e20707",
    msg: "Data from this website shouldn't be relied upon anymore",
  },
};

let intervalID = null;
let batchResp = null;
let reqTime = null;

// Generated by Generative AI AAAAAAAAAAAAAAAAAA
function formatTimeComponents(date, params={isUTC: false}) {
  const addPaddingDate = (num) => String(num).padStart(2, "0");

  return {
    hours: addPaddingDate(params.isUTC ? date.getUTCHours() : date.getHours()),
    minutes: addPaddingDate(params.isUTC ? date.getUTCMinutes() : date.getMinutes()),
    seconds: addPaddingDate(params.isUTC ? date.getUTCSeconds() : date.getSeconds()),
  };
}

function getStartEndInfo(idxInArr, timeRemArr) {
  const idxToUseForLastTime = (idxInArr != timeRemArr.length - 1) ? idxInArr + 1 : 0;

  return {
    start_date: new Date(reqTime + (timeRemArr[idxInArr]["time_remaining"] * 1000)),
    end_date: new Date(reqTime + (timeRemArr[idxToUseForLastTime]["time_remaining"] * 1000))
  };
}

function formatNumTimeSince(numTimeSince) {
  let timeLeftToStr = null;

  // Garbage. Too lazy to fix
  if (Math.floor(numTimeSince) < 60) {
    timeLeftToStr = `${Math.floor(numTimeSince)} ${(Math.floor(numTimeSince) === 1) ? "second" : "seconds"}`;
  } else if (Math.floor(numTimeSince) < 3600) {
    timeLeftToStr = `${Math.floor(numTimeSince / 60)} ${(Math.floor(numTimeSince / 60) === 1) ? "minute" : "minutes"}`;
  } else if (Math.floor(numTimeSince) < 86400) {
    timeLeftToStr = `${Math.floor(numTimeSince / 60 / 60)} ${(Math.floor(numTimeSince / 60 / 60) === 1) ? "hour" : "hours"}`;
  } else if (Math.floor(numTimeSince) < 604800) {
    timeLeftToStr = `${Math.floor(numTimeSince / 60 / 60 / 24)} ${(Math.floor(numTimeSince / 60 / 60 / 24) === 1) ? "day" : "days"}`;
  } else if (Math.floor(numTimeSince) < 2628000) {
    timeLeftToStr = `${Math.floor(numTimeSince / 60 / 60 / 24 / 7)} ${(Math.floor(numTimeSince / 60 / 60 / 24 / 7) === 1) ? "week" : "weeks"}`;
  } else if (Math.floor(numTimeSince) < 31536000) {
    timeLeftToStr = `${Math.floor(numTimeSince / 60 / 60 / 24 / 7 / 4.345238095238095)} ${(Math.floor(numTimeSince / 60 / 60 / 24 / 7 / 4.345238095238095) === 1) ? "month" : "months"}`;
  } else {
    timeLeftToStr = `${Math.floor(numTimeSince / 60 / 60 / 24 / 7 / 4.345238095238095 / 12)} ${(Math.floor(numTimeSince / 60 / 60 / 24 / 7 / 4.345238095238095 / 12) === 1) ? "year" : "years"}`;
  }

  return {
    timeSinceNum: parseInt(timeLeftToStr.split(" ")[0]),
    unit: timeLeftToStr.split(" ")[1],
    strRes: timeLeftToStr,
  };
}

async function reloadAll() {
  clearInterval(intervalID); // This is null, and still no errors? WTF?
  intervalID = null;
  batchResp = null;
  reqTime = null;

  state_utils.convertUIToLoadAppearance();
  document.querySelectorAll(".music_schedule").forEach(e => {
    e.remove();
  });

  const info = await fetch("/api/batch_info");
  const res = await info.json();
  if (info.status === 404) {
    document.querySelector("#simple_error_display").innerText = res["msg"];
    state_utils.convertUIToErrorAppearance();
    return;
  } else if (!info.ok) {
    document.querySelector("#simple_error_display").innerText = "An unknown error has occured while getting the response from the server. See the console for more detail.";
    state_utils.convertUIToErrorAppearance();
    console.error("Got a non-2xx response (not 404) from the server. Dumping request... ");
    console.error(info);
    return;
  }

  reqTime = Date.now();

  state_utils.convertUIToLoadedAppearance();
  document.querySelector("#curr_playing").innerText = res["curr_playing_music"];

  res["time_remaining_all"].forEach(e => {
    const idx = res["time_remaining_all"].findIndex(f => f["music_name"] === e["music_name"]);
    const info = getStartEndInfo(idx, res["time_remaining_all"]);

    const start = formatTimeComponents(info.start_date);
    const end = formatTimeComponents(info.end_date);

    const formatted = {
      start_hours: start.hours,
      start_minutes: start.minutes,
      start_seconds: start.seconds,
      end_hours: end.hours,
      end_minutes: end.minutes,
      end_seconds: end.seconds,
    };

    document.querySelector("#upcoming_songs").insertAdjacentHTML("beforeend", `<div class="music_schedule">
      <span id="song">${e["music_name"]}</span>
      <small><strong id="time">${formatted.start_hours}:${formatted.start_minutes}:${formatted.start_seconds} - ${formatted.end_hours}:${formatted.end_minutes}:${formatted.end_seconds}</strong></small>
      <small id="live_in"></small>
    </div>`);
  });

  const lastUpdated = formatNumTimeSince((Date.now() / 1000) - res["advanced_stats"]["last_updated"]);

  let updateLevel = null;
  switch (lastUpdated.unit) {
    case "second":
    case "seconds":
    case "minute":
    case "minutes":
    case "hour":
    case "hours":
      if (lastUpdated.timeSinceNum <= 12) {
        updateLevel = LASTUPDATE_LEVEL.GOOD;
        break;
      }
      updateLevel = LASTUPDATE_LEVEL.SLIGHT_OUTOFDATE;
      break;
    case "day":
      updateLevel = LASTUPDATE_LEVEL.SLIGHT_OUTOFDATE;
    case "days":
    case "week":
    case "weeks":
    case "month":
      updateLevel = LASTUPDATE_LEVEL.OUTOFDATE;
      break;
    case "months":
    case "year":
    case "years":
      updateLevel = LASTUPDATE_LEVEL.OUTOFDATE_SEVERE;
      break;
    default:
      document.querySelector("#simple_error_display").innerText = `Unknown format passed ${lastUpdated.unit}`;
      state_utils.convertUIToErrorAppearance();
      break;
  }

  document.querySelector("#last_updated").innerText = lastUpdated.strRes;
  document.querySelector("#updated_notif").style = `color: #${updateLevel.color}`;
  
  document.querySelector(".last_updated_wrapper").style = `color: #${updateLevel.color}`;
  document.querySelector("#updated_notif").innerText = updateLevel.msg;

  // To not create the placeholder appearance for the first time
  batchResp = res;
  updateTimers();
  intervalID = setInterval(updateTimers, 250);
}

function updateTimers() {
  document.querySelectorAll(".music_schedule").forEach(e => {
    const idx = batchResp["time_remaining_all"].findIndex(f => f["music_name"] === e.querySelector("#song").innerText);

    const info = getStartEndInfo(idx, batchResp["time_remaining_all"]);
    const timeLeft = info["start_date"].getTime() - Date.now();

    if (timeLeft <= 0) {
      document.querySelector("#curr_playing").innerText = e.querySelector("#song").innerText;
      e.remove();
      return;
    }

    e.querySelector("#live_in").innerText = `Live in ${formatNumTimeSince(timeLeft / 1000).strRes}`;
  });
}

// (probably) unnecessarily async
(async () => {
  await reloadAll();
})();
document.querySelector("#reload_btn").addEventListener("click", async () => {
  await reloadAll();
});
document.querySelector("#adv_stats_btn").addEventListener("click", () => {
  //const formattedTime = formatTimeComponents(new Date(batchResp["advanced_stats"]["last_updated"]), {isUTC: true});
  const time = new Date(batchResp["advanced_stats"]["last_updated"] * 1000);
  alert(`Last music name update: ${batchResp["advanced_stats"]["music"]}\nLast music update time (UTC) : ${time.toUTCString()}\nLast music update time (UTC+${-time.getTimezoneOffset() / 60}) (your local timezone offset) : ${time.toString()}`);
});